# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

condense_count <- function(x, z, weight, drop = FALSE) {
    .Call('bigvis_condense_count', PACKAGE = 'bigvis', x, z, weight, drop)
}

condense_sum <- function(x, z, weight, drop = FALSE) {
    .Call('bigvis_condense_sum', PACKAGE = 'bigvis', x, z, weight, drop)
}

condense_mean <- function(x, z, weight, drop = FALSE) {
    .Call('bigvis_condense_mean', PACKAGE = 'bigvis', x, z, weight, drop)
}

condense_sd <- function(x, z, weight, drop = FALSE) {
    .Call('bigvis_condense_sd', PACKAGE = 'bigvis', x, z, weight, drop)
}

condense_median <- function(x, z, weight, drop = FALSE) {
    .Call('bigvis_condense_median', PACKAGE = 'bigvis', x, z, weight, drop)
}

double_diff_sum <- function(bin, count) {
    .Call('bigvis_double_diff_sum', PACKAGE = 'bigvis', bin, count)
}

#' Efficient implementation of range.
#'
#' This is an efficient C++ implementation of range for numeric vectors:
#' it avoids S3 dispatch, and computes both min and max in a single pass
#' through the input.
#'
#' If \code{x} has a \code{range} attribute (e.g. it's a \code{\link{ranged}}
#' object), it will be used instead of computing the range from scratch.
#' 
#' @param x a numeric vector, or a \code{\link{ranged}} object
#' @param finite If \code{TRUE} ignores missing values and infinities. Note
#'   that if the vector is empty, or only contains missing values, 
#'   \code{frange} will return \code{c(Inf, -Inf)} because those are the
#'   identity values for \code{\link{min}} and \code{\link{max}} respectively.
#' @export
#' @examples
#' x <- runif(1e6)
#' system.time(range(x))
#' system.time(frange(x))
#'
#' rx <- ranged(x)
#' system.time(frange(rx))
frange <- function(x, finite = TRUE) {
    .Call('bigvis_frange', PACKAGE = 'bigvis', x, finite)
}

group_fixed <- function(x, width, origin = 0) {
    .Call('bigvis_group_fixed', PACKAGE = 'bigvis', x, width, origin)
}

group_rect <- function(x, y, x_width, y_width, x_origin, y_origin) {
    .Call('bigvis_group_rect', PACKAGE = 'bigvis', x, y, x_width, y_width, x_origin, y_origin)
}

group_hex <- function(x, y, x_width, y_width, x_origin, y_origin, x_max) {
    .Call('bigvis_group_hex', PACKAGE = 'bigvis', x, y, x_width, y_width, x_origin, y_origin, x_max)
}

lowerBound <- function(x, breaks) {
    .Call('bigvis_lowerBound', PACKAGE = 'bigvis', x, breaks)
}

#' Smooth an n-dimensional condensed dataset with 
smooth_nd_1 <- function(grid_in, z_in, grid_out, var, h) {
    .Call('bigvis_smooth_nd_1', PACKAGE = 'bigvis', grid_in, z_in, grid_out, var, h)
}

#' 1d normal kernel smoothing.
#'
#' This is a variant of \code{\link{density}} for calculating weighted 
#' means or weighted sums, with weights determined by a normal kernel. 
#' Both the input and the output can have irregular locations.
#'
#' @param x ordered vector of x positions
#' @param z vector of values
#' @param x_out vector of x positions to produce smoothed values
#' @param sd standard deviation of normal kernel (the bandwidth of the 
#'   smoother)
#' @param standardise if \code{TRUE}, divides the weighted sum at each location
#'   by the sum of the weights. This is usually what you want for pre-binned
#'   data, as it interpolates between the points, rather than redistributing 
#'   the density.  Any locations in \code{x_out} that are more than 4 standard
#'   deviations away from \code{x_in} will be \code{NaN}.
#' @keywords internal
smooth1d <- function(x, z, x_out, sd, standardise = TRUE) {
    .Call('bigvis_smooth1d', PACKAGE = 'bigvis', x, z, x_out, sd, standardise)
}

smooth2d_full <- function(x, y, z, x_out, y_out, x_sd, y_sd, standardise = TRUE) {
    .Call('bigvis_smooth2d_full', PACKAGE = 'bigvis', x, y, z, x_out, y_out, x_sd, y_sd, standardise)
}

smooth2d2 <- function(x, y, z, x_out, y_out, x_sd, y_sd, standardise = TRUE) {
    .Call('bigvis_smooth2d2', PACKAGE = 'bigvis', x, y, z, x_out, y_out, x_sd, y_sd, standardise)
}

smooth2d3 <- function(x, y, z, x_width, x_origin, y_width, y_origin, x_sd, y_sd, standardise = TRUE) {
    .Call('bigvis_smooth2d3', PACKAGE = 'bigvis', x, y, z, x_width, x_origin, y_width, y_origin, x_sd, y_sd, standardise)
}

bisquare <- function(u, b) {
    .Call('bigvis_bisquare', PACKAGE = 'bigvis', u, b)
}

regress <- function(x, y, w) {
    .Call('bigvis_regress', PACKAGE = 'bigvis', x, y, w)
}

medianC <- function(x_) {
    .Call('bigvis_median', PACKAGE = 'bigvis', x_)
}

simple_loess <- function(x, y, w, iterations = 3L) {
    .Call('bigvis_simple_loess', PACKAGE = 'bigvis', x, y, w, iterations)
}

compute_moments <- function(x) {
    .Call('bigvis_compute_moments', PACKAGE = 'bigvis', x)
}

compute_sum <- function(x) {
    .Call('bigvis_compute_sum', PACKAGE = 'bigvis', x)
}

compute_median <- function(x) {
    .Call('bigvis_compute_median', PACKAGE = 'bigvis', x)
}

