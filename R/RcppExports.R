# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Convolution: 1d
#'
#' Automatically zero-pads sample so that kernel trails off to zero.
#' 
#' @author Dirk Eddelbuettel, Romain Francois
convolve_1d <- function(x, kernel) {
    .Call('bigvis_convolve_1d', PACKAGE = 'bigvis', x, kernel)
}

convolver_1d <- function(x, kernel) {
    .Call('bigvis_convolver_1d', PACKAGE = 'bigvis', x, kernel)
}

convolve_2d <- function(sample, kernel) {
    .Call('bigvis_convolve_2d', PACKAGE = 'bigvis', sample, kernel)
}

group_fixed <- function(x, width, origin = 0) {
    .Call('bigvis_group_fixed', PACKAGE = 'bigvis', x, width, origin)
}

group_breaks <- function(x, breaks) {
    .Call('bigvis_group_breaks', PACKAGE = 'bigvis', x, breaks)
}

group_integer <- function(x, origin = 0) {
    .Call('bigvis_group_integer', PACKAGE = 'bigvis', x, origin)
}

group_rect <- function(x, y, x_width, y_width, x_origin, y_origin, x_bins) {
    .Call('bigvis_group_rect', PACKAGE = 'bigvis', x, y, x_width, y_width, x_origin, y_origin, x_bins)
}

group_hex <- function(x, y, x_width, y_width, x_origin, y_origin, x_max) {
    .Call('bigvis_group_hex', PACKAGE = 'bigvis', x, y, x_width, y_width, x_origin, y_origin, x_max)
}

compute_count_breaks <- function(x, y, weight, breaks) {
    .Call('bigvis_compute_count_breaks', PACKAGE = 'bigvis', x, y, weight, breaks)
}

compute_count_fixed <- function(x, y, weight, width, origin) {
    .Call('bigvis_compute_count_fixed', PACKAGE = 'bigvis', x, y, weight, width, origin)
}

compute_sum_breaks <- function(x, y, weight, breaks) {
    .Call('bigvis_compute_sum_breaks', PACKAGE = 'bigvis', x, y, weight, breaks)
}

compute_sum_fixed <- function(x, y, weight, width, origin) {
    .Call('bigvis_compute_sum_fixed', PACKAGE = 'bigvis', x, y, weight, width, origin)
}

compute_mean_breaks <- function(x, y, weight, breaks) {
    .Call('bigvis_compute_mean_breaks', PACKAGE = 'bigvis', x, y, weight, breaks)
}

compute_mean_fixed <- function(x, y, weight, width, origin) {
    .Call('bigvis_compute_mean_fixed', PACKAGE = 'bigvis', x, y, weight, width, origin)
}

compute_median_breaks <- function(x, y, weight, breaks) {
    .Call('bigvis_compute_median_breaks', PACKAGE = 'bigvis', x, y, weight, breaks)
}

compute_median_fixed <- function(x, y, weight, width, origin) {
    .Call('bigvis_compute_median_fixed', PACKAGE = 'bigvis', x, y, weight, width, origin)
}

compute_sd_breaks <- function(x, y, weight, breaks) {
    .Call('bigvis_compute_sd_breaks', PACKAGE = 'bigvis', x, y, weight, breaks)
}

compute_sd_fixed <- function(x, y, weight, width, origin) {
    .Call('bigvis_compute_sd_fixed', PACKAGE = 'bigvis', x, y, weight, width, origin)
}

#' Efficient implementation of range.
#'
#' This is an efficient C++ implementation of range for numeric vectors:
#' it avoids S3 dispatch, and computes both min and max in a single pass
#' through the input.
#' 
#' @param x a numeric vector
#' @param na_rm should missing values be removed?
#' @export
#' @examples
#' x <- runif(1e6)
#' system.time(range(x))
#' system.time(frange(x))
frange <- function(x, na_rm = TRUE) {
    .Call('bigvis_frange', PACKAGE = 'bigvis', x, na_rm)
}

