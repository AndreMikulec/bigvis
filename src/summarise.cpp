#include <Rcpp.h>
#include "group.hpp"
#include <bigvis.h>
#include "summary.hpp"
using namespace Rcpp;

template<typename Summary>
List summarise_nd(const BinnedVectors& group,
                  const NumericVector& z,
                  const NumericVector& weight,
                  const Summary& summary) {

  int n_groups = group.ngroups();
  int n_obs = group.size();
  std::map<int, Summary> summaries;

  const NumericVector& weight_ = (weight.size() > 0) ? weight :
    rep(NumericVector::create(1), n_obs);
  const NumericVector& z_ = (z.size() > 0) ? z :
    rep(NumericVector::create(1), n_obs);

  // Push data into summaries
  for(int i = 0; i < n_obs; ++i) {
    int bin = group.bin_i(i);

    typename std::map<int, Summary>::iterator loc = summaries.find(bin);
    if (loc == summaries.end()) {
      Summary new_sum(summary);
      new_sum.push(z_[i], weight_[i]);
      summaries.insert(std::pair<int, Summary>(bin, new_sum));
    } else {
      (loc->second).push(z_[i], weight_[i]);
    }
  }

  // Get summaries and bins
  int m = summary.size();
  int n_bins = summaries.size();
  NumericMatrix out(n_bins, m), bin(n_bins, n_groups);
  typename std::map<int, Summary>::iterator summaries_it = summaries.begin(),
    summaries_end = summaries.end();

  for (int i = 0; summaries_it != summaries_end; ++summaries_it, ++i) {
    for (int j = 0; j < m; ++j) {
      out(i, j) = (summaries_it->second).compute(j);
    }

    std::vector<double> bins = group.unbin(summaries_it->first);
    for (int j = 0; j < n_bins; ++j) {
      bin(i, j) = bins[j];
    }
  }

  // Name output columns
  CharacterVector colnames(m);
  for (int j = 0; j < m; ++j) {
    colnames[j] = summary.name(j);
  }
  out.attr("dimnames") = List::create(CharacterVector::create(), colnames);

  return List::create(bin, out);
}

template<typename Stat>
List summarise(const BinnedVectorReference& group, const NumericVector& z, 
                        const NumericVector& weight, const Stat& stat) {
  int n_obs = group.size();
  int n_bins = group.nbins();

  const NumericVector& weight_ = (weight.size() > 0) ? weight : 
    rep(NumericVector::create(1), n_obs);
  const NumericVector& z_ = (z.size() > 0) ? z : 
    rep(NumericVector::create(1), n_obs);

  // Push values into summaries
  std::vector<Stat> stats(n_bins + 1, stat);
  for(int i = 0; i < n_obs; ++i) {
    int bin = group.bin_i(i);
    stats.at(bin).push(z_[i], weight_[i]);      
  }

  // Compute values from summaries
  int m = stats[0].size();
  NumericMatrix res(n_bins, m);
  for (int i = 0; i < n_bins; ++i) {
    for (int j = 0; j < m; ++j) {
      res(i, j) = stats[i].compute(j);
    }
  }
  CharacterVector colnames(m);
  for (int j = 0; j < m; ++j) {
    colnames[j] = stats[0].name(j);
  }
  res.attr("dimnames") = List::create(CharacterVector::create(), colnames);

  // Compute mid-bins
  NumericVector bins(n_bins);
  for (int i = 0; i < n_bins; ++i) {
    bins[i] = group.unbin(i);
  }

  return List::create(res, bins);
}

// -----------------------------------------------------------------------------
// Autogenerated by summarise-gen.r
// [[Rcpp::export]]
List summarise_count(const BinnedVectorReference& x, const NumericVector& z, const NumericVector& weight) {
  return summarise(x, z, weight, SummarySum(0));
}

// [[Rcpp::export]]
List summarise_sum(const BinnedVectorReference& x, const NumericVector& z, const NumericVector& weight) {
  return summarise(x, z, weight, SummarySum(1));
}

// [[Rcpp::export]]
List summarise_mean(const BinnedVectorReference& x, const NumericVector& z, const NumericVector& weight) {
  return summarise(x, z, weight, SummaryMoments(1));
}

// [[Rcpp::export]]
List summarise_sd(const BinnedVectorReference& x, const NumericVector& z, const NumericVector& weight) {
  return summarise(x, z, weight, SummaryMoments(2));
}

// [[Rcpp::export]]
List summarise_median(const BinnedVectorReference& x, const NumericVector& z, const NumericVector& weight) {
  return summarise(x, z, weight, SummaryMedian());
}

